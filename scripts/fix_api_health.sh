#!/usr/bin/env bash
# scripts/fix_api_health.sh
# Ensure a fast /_healthz endpoint exists on the FastAPI app and wire a robust compose healthcheck.

set -Eeuo pipefail

# -------- Config (override via env or flags) --------
HEALTH_PATH="${HEALTH_PATH:-/_healthz}"
HEALTH_PORT="${HEALTH_PORT:-8000}"
COMPOSE_BASE="${COMPOSE_BASE:-infra/docker-compose.yml}"
COMPOSE_HEALTH="${COMPOSE_HEALTH:-infra/docker-compose.health.override.yml}"
SERVICE="${SERVICE:-orchestrator}"
MAIN_PY="${MAIN_PY:-}"

FORCE_INJECT="false"

usage() {
  cat <<EOF
Usage: $(basename "$0") [--force-inject] [--service NAME] [--main-py PATH]
Env overrides:
  HEALTH_PATH (default ${HEALTH_PATH})
  HEALTH_PORT (default ${HEALTH_PORT})
  COMPOSE_BASE (default ${COMPOSE_BASE})
  COMPOSE_HEALTH (default ${COMPOSE_HEALTH})
  SERVICE (default ${SERVICE})
  MAIN_PY (default: auto-detect)
EOF
}

# -------- Args --------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --force-inject) FORCE_INJECT="true"; shift ;;
    --service) SERVICE="$2"; shift 2 ;;
    --main-py) MAIN_PY="$2"; shift 2 ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown arg: $1"; usage; exit 1 ;;
  esac
done

log() { printf "\e[1;36m==>\e[0m %s\n" "$*"; }
warn() { printf "\e[1;33m!!\e[0m %s\n" "$*" >&2; }
die() { printf "\e[1;31mXX\e[0m %s\n" "$*" >&2; exit 1; }

# -------- Find repo root --------
ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT"

# -------- Locate main.py --------
if [[ -z "$MAIN_PY" ]]; then
  # Common orchestrator paths first
  for p in \
    backend/orchestrator/app/main.py \
    backend/behavior_analytics/app/main.py \
    backend/app/main.py \
    app/main.py
  do
    [[ -f "$p" ]] && MAIN_PY="$p" && break
  done
  # Fallback: first tracked *app/main.py
  [[ -z "$MAIN_PY" ]] && MAIN_PY="$(git ls-files '*app/main.py' | head -n1 || true)"
fi
[[ -n "$MAIN_PY" && -f "$MAIN_PY" ]] || die "Could not find FastAPI main.py. Pass --main-py PATH or MAIN_PY=…"

log "Found: $MAIN_PY"

# -------- Precise route detection --------
HAS_ROUTE="false"
if grep -Eq '@app\.(get|head)\("'"${HEALTH_PATH//\//\\/}"'"' "$MAIN_PY"; then
  HAS_ROUTE="true"
fi

if [[ "$FORCE_INJECT" == "true" ]]; then
  warn "Forcing injection of ${HEALTH_PATH} route."
  HAS_ROUTE="false"
fi

# -------- Inject /_healthz if missing --------
if [[ "$HAS_ROUTE" == "true" ]]; then
  log "${HEALTH_PATH} already present — skipping injection."
else
  log "Injecting ${HEALTH_PATH} into ${MAIN_PY}"
  cat >>"$MAIN_PY" <<PY

# --- injected by fix_api_health.sh ---
try:
    from fastapi import FastAPI
except Exception:
    pass

# Ensure a global FastAPI instance named "app" exists
try:
    app  # type: ignore  # noqa: F821
except NameError:  # pragma: no cover
    app = FastAPI()

@app.get("${HEALTH_PATH}", include_in_schema=False)
async def _healthz():
    return {"status": "ok"}
# --- end injected ---
PY
fi

# -------- Write compose health override (Python-based test) --------
mkdir -p "$(dirname "$COMPOSE_HEALTH")"
log "Writing ${COMPOSE_HEALTH}"
cat > "$COMPOSE_HEALTH" <<YML
# generated by scripts/fix_api_health.sh
services:
  ${SERVICE}:
    healthcheck:
      test:
        - CMD-SHELL
        - >-
          python -c "import urllib.request,sys,socket;
          socket.setdefaulttimeout(2);
          url='http://127.0.0.1:${HEALTH_PORT}${HEALTH_PATH}';
          try:
            r=urllib.request.urlopen(url);
            c=getattr(r,'status',getattr(r,'code',200));
            sys.exit(0 if 200<=c<400 else 1)
          except Exception as e:
            sys.exit(1)"
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s
YML

# -------- Rebuild & restart only the target service with override --------
log "Building ${SERVICE}…"
docker compose -f "$COMPOSE_BASE" -f "$COMPOSE_HEALTH" build "$SERVICE"

log "Starting ${SERVICE} with health override…"
docker compose -f "$COMPOSE_BASE" -f "$COMPOSE_HEALTH" up -d "$SERVICE"

CID="$(docker compose -f "$COMPOSE_BASE" -f "$COMPOSE_HEALTH" ps -q "$SERVICE" || true)"
[[ -n "$CID" ]] || die "Could not resolve container id for service: ${SERVICE}"

# Helpful diagnostics on failure/interrupt
trap 'echo; warn "Diagnostics on exit:"; docker inspect "$CID" --format "{{.State.Status}} / {{.State.Health.Status}}" || true; echo; docker inspect "$CID" --format "{{range .State.Health.Log}}{{.Start}} | {{.ExitCode}} | {{.Output}}{{println}}{{end}}" | tail -n 20 || true; echo; docker logs --tail=200 "$CID" || true' EXIT

# -------- Wait for healthy --------
log "Waiting for ${SERVICE} health (up to ~2.5 min)…"
TRIES=30
SLEEP=5
for i in $(seq 1 "$TRIES"); do
  STATUS="$(docker inspect -f '{{.State.Health.Status}}' "$CID" 2>/dev/null || echo starting)"
  printf "   [%02d/%02d] %s\r" "$i" "$TRIES" "$STATUS"
  if [[ "$STATUS" == "healthy" ]]; then
    printf "\n"; log "Service is healthy ✅"
    trap - EXIT
    break
  fi
  sleep "$SLEEP"
done
echo

if ! docker inspect -f '{{.State.Health.Status}}' "$CID" 2>/dev/null | grep -q healthy; then
  warn "Service did not become healthy in time."
  exit 1
fi

# -------- Verify from host once healthy --------
set +e
HTTP="$(curl -sSf -o /dev/null -w '%{http_code}' "http://127.0.0.1:${HEALTH_PORT}${HEALTH_PATH}")"
set -e
log "GET ${HEALTH_PATH} -> HTTP ${HTTP}"
echo "Done."
